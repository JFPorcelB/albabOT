<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Albito ‚Äî Chat</title>
  <style>
    :root{
      --udlba-azul:#061E3D;
      --udlba-magenta:#E0004D;
      --panel:#0b1020;
      --panel2:#0a0f1e;
      --ink:#e5e7eb;
      --muted:#cbd5e1;
      --chip:#2a2f3c;
      --line:rgba(255,255,255,.10);
      --radius:22px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      background:
        radial-gradient(900px 500px at 15% 10%, rgba(224,0,77,.16), transparent 55%),
        radial-gradient(900px 500px at 80% 15%, rgba(6,30,61,.35), transparent 60%),
        linear-gradient(180deg, #070a13 0%, #0c1732 50%, #0b1022 100%);
      color: var(--ink);
    }

    /* embed mode */
    body.embed .wrap{ max-width:100%; padding:0; }
    body.embed .shell{ border-radius: 0; box-shadow:none; border:none; }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 18px;
      height:100%;
    }
    .shell{
      height: 100%;
      display:flex;
      flex-direction:column;
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow: 0 22px 80px rgba(0,0,0,.45);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      backdrop-filter: blur(8px);
    }

    .top{
      padding: 14px 14px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.04);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    .brand .avatar{
      width:56px;height:56px;
      border-radius: 50%;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      flex:0 0 auto;
      display:grid;place-items:center;
    }
    .brand .avatar img{ width:100%;height:100%; object-fit:cover; }
    .brand .txt{ min-width:0; }
    .brand h1{
      margin:0;
      font-size: 16px;
      letter-spacing:.2px;
      text-transform:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand p{
      margin:2px 0 0;
      font-size: 12.5px;
      color: rgba(229,231,235,.78);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex:0 0 auto;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(229,231,235,.9);
      white-space:nowrap;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:#f59e0b;
      box-shadow: 0 0 0 3px rgba(245,158,11,.18);
    }
    .dot.ok{ background:#22c55e; box-shadow: 0 0 0 3px rgba(34,197,94,.18); }
    .dot.bad{ background:#ef4444; box-shadow: 0 0 0 3px rgba(239,68,68,.18); }

    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(229,231,235,.95);
      border-radius: 999px;
      padding: 8px 12px;
      font-weight: 700;
      font-size: 12.5px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }

    .tipbar{
      padding: 10px 14px;
      font-size: 12.5px;
      color: rgba(229,231,235,.88);
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.03);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }

    .main{
      flex: 1 1 auto;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .chat{
      flex: 1 1 auto;
      overflow:auto;
      padding: 14px;
      scroll-behavior:smooth;
    }

    .row{
      display:flex;
      gap:10px;
      margin: 10px 0;
      align-items:flex-end;
    }
    .row.me{ justify-content:flex-end; }
    .row.bot{ justify-content:flex-start; }

    .msgAvatar{
      width:52px;height:52px;
      border-radius:50%;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      flex:0 0 auto;
      display:grid;place-items:center;
    }
    .msgAvatar img{ width:100%;height:100%; object-fit:cover; }

    .bubble{
      max-width: min(680px, 84%);
      border-radius: 20px;
      padding: 12px 14px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 14px 36px rgba(0,0,0,.22);
      line-height:1.45;
      font-size: 14px;
      position:relative;
      word-break:break-word;
      white-space:pre-wrap;
    }

    .row.bot .bubble{
      background: linear-gradient(145deg, rgba(224,0,77,.38), rgba(224,0,77,.18));
    }
    .row.me .bubble{
      background: linear-gradient(145deg, rgba(6,30,61,.55), rgba(6,30,61,.25));
    }

    .who{
      font-weight: 800;
      font-size: 12px;
      opacity:.9;
      margin-bottom: 4px;
    }

    .controls{
      padding: 10px 14px 12px;
      border-top:1px solid var(--line);
      background: rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 9px 12px;
      border-radius: 999px;
      border:1px dashed rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      font-size: 12.5px;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .radios{
      display:flex; gap:10px; align-items:center;
      padding: 6px;
      border-radius: 999px;
      border:1px dashed rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
    }
    .radio{
      display:flex; align-items:center; gap:6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12.5px;
      user-select:none;
    }

    .composer{
      padding: 10px 14px 14px;
      background: rgba(255,255,255,.03);
      border-top:1px solid var(--line);
      display:flex;
      gap:10px;
      align-items:center;
    }
    .input{
      flex:1 1 auto;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(229,231,235,.96);
      padding: 12px 12px;
      font-size: 14px;
      outline:none;
    }
    .send{
      flex:0 0 auto;
      border-radius: 16px;
      padding: 12px 16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(224,0,77,.72);
      color:#fff;
      font-weight: 900;
      cursor:pointer;
    }
    .send:hover{ background: rgba(224,0,77,.86); }

    /* NO chips */
    .chips, .quickChips, .suggestions { display:none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="shell">
      <div class="top">
        <div class="brand">
          <div class="avatar">
            <img id="brandAvatar" src="albito.jpeg" alt="Albito" onerror="this.onerror=null;this.src='albito.jpg'">
          </div>
          <div class="txt">
            <h1>Albito ‚Äî Chat para la Jornada Directiva</h1>
            <p>Respondo solo con los textos. Si no hay evidencia, lo dir√© (sin inventar).</p>
          </div>
        </div>

        <div class="actions">
          <div class="pill" id="kbPill"><span class="dot" id="kbDot"></span><span id="kbText">cargando base‚Ä¶</span></div>
          <button class="btn" id="btnClear">Limpiar</button>
          <button class="btn" id="btnCopy">Copiar √∫ltima</button>
        </div>
      </div>

      <div class="tipbar">
        <div><b>Tip:</b> pregunta por<b>eje</b>, <b>concepto</b> o <b>objetivo</b>.</div>
        <div>Tip: cambia el nivel de detalle abajo.</div>
      </div>

      <div class="main">
        <div class="chat" id="chat"></div>

        <div class="controls">
          <label class="toggle"><input type="checkbox" id="tone" checked> Tono simp√°tico üê•</label>
          <label class="toggle"><input type="checkbox" id="showEvidence" checked> Mostrar evidencia</label>

          <div class="radios" role="radiogroup" aria-label="Detalle">
            <label class="radio"><input type="radio" name="detail" id="modeBrief" value="brief" checked> Breve</label>
            <label class="radio"><input type="radio" name="detail" id="modeDetail" value="detail"> En detalle</label>
          </div>
        </div>

        <div class="composer">
          <input class="input" id="q" placeholder="Escribe tu pregunta‚Ä¶ (Enter para enviar)" autocomplete="off" />
          <button class="send" id="btnSend">Enviar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ====== Config ======
  const QA_FILES = [
    { url: "./estrategia_es_QA_50_enriquecido.json",        source: "Estrategia ES" },
    { url: "./universidades_futuro_QA_50.json",             source: "Universidades del futuro" },
    { url: "./autores_vs_objetivos_QA_50_enriquecido.json", source: "Autores vs Objetivos" },
    { url: "./directrices_paises_QA_50_enriquecido.json",   source: "Directrices (pa√≠ses)" },
  ];

  // ---- Embed mode (para iframe) ----
  const params = new URLSearchParams(location.search);
  if (params.get("embed") === "1") document.body.classList.add("embed");

  // ====== Helpers DOM ======
  const $ = (id) => document.getElementById(id);
  const chatEl = $("chat");

  function addMsg(who, text) {
    const row = document.createElement("div");
    row.className = "row " + (who === "me" ? "me" : "bot");

    if (who === "bot") {
      const av = document.createElement("div");
      av.className = "msgAvatar";
      const img = document.createElement("img");
      img.src = "albito.jpeg";
      img.alt = "Albito";
      img.onerror = () => { img.onerror = null; img.src = "albito.jpg"; };
      av.appendChild(img);
      row.appendChild(av);
    }

    const bubble = document.createElement("div");
    bubble.className = "bubble";

    const label = document.createElement("div");
    label.className = "who";
    label.textContent = (who === "me") ? "T√∫" : "Albito";
    bubble.appendChild(label);

    const body = document.createElement("div");
    body.className = "body";
    body.textContent = text;
    bubble.appendChild(body);

    row.appendChild(bubble);
    chatEl.appendChild(row);
    chatEl.scrollTop = chatEl.scrollHeight;
  }

  function setKBStatus(state, text) {
    const dot = $("kbDot");
    dot.classList.remove("ok", "bad");
    if (state === "ok") dot.classList.add("ok");
    if (state === "bad") dot.classList.add("bad");
    $("kbText").textContent = text;
  }

  function normalize(s) {
    return (s || "")
      .toString()
      .toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-z0-9\s\-\_]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  const STOP = new Set(["de","la","el","los","las","y","o","un","una","para","por","en","a","del","al","que","con","sin","sobre","como","mas","m√°s","es","son","se","su","sus"]);
  function tokens(q) {
    const t = normalize(q).split(" ").filter(Boolean).filter(w => !STOP.has(w));
    return [...new Set(t)];
  }
  function onlyAnswerFromBlock(b){
  // Si viene separado (ideal)
  if (b && typeof b.answer === "string" && b.answer.trim()) return b.answer.trim();

  const t = String((b && b.text) || "");
  // Busca "A:" en cualquier parte
  const m = t.match(/\nA:\s*([\s\S]*)/i);
  let a = (m ? m[1] : t).trim();

  // Corta cualquier cosa tipo "Fuente:" o "Q:" que venga despu√©s
  a = a.replace(/\nFuente:\s*[\s\S]*/i, "").trim();
  a = a.replace(/^Q:\s*[\s\S]*?\nA:\s*/i, "").trim(); // por si qued√≥ pegado

  return a;
}


  function safeSentences(txt) {
    const s = (txt || "").replace(/\s+/g, " ").trim();
    if (!s) return [];
    // corta por puntos sin usar lookbehind (m√°s compatible)
    return s.split(/(?<=[.!?])\s+|[\n\r]+/g).filter(Boolean);
  }

  function firstSentences(raw, maxChars) {
    const s = (raw || "").replace(/\s+/g, " ").trim();
    if (!s) return "";
    const parts = safeSentences(s);
    let out = "";
    for (const p of parts) {
      const next = (out ? out + " " : "") + p;
      if (next.length > maxChars) break;
      out = next;
      if (out.length >= Math.min(220, maxChars)) break;
    }
    if (!out) out = s.slice(0, maxChars);
    if (out.length < s.length) out += "‚Ä¶";
    return out;
  }

  // ====== KB ======
  let BLOCKS = []; // <- √öNICA fuente para responder

  async function fetchJson(url, ms = 12000) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), ms);
    try {
      const res = await fetch(url, { cache: "no-store", signal: ctrl.signal });
      if (!res.ok) throw new Error(`${url} -> HTTP ${res.status}`);
      return await res.json();
    } finally {
      clearTimeout(t);
    }
  }

  function splitQA(text){
  const raw = (text ?? "").toString();
  // intenta separar "Q: ... A: ..."
  const idx = raw.search(/\n\s*A:\s*/i);
  if (idx === -1) return { q: "", a: raw.trim() };

  const qPart = raw.slice(0, idx).replace(/^Q:\s*/i, "").trim();
  const aPart = raw.slice(idx).replace(/^\s*A:\s*/i, "").trim();
  return { q: qPart, a: aPart };
}

function normalizeToBlocks(json, sourceName, fileUrl) {
  const out = [];

  // Caso A: { blocks: [...] }
  if (json && Array.isArray(json.blocks)) {
    json.blocks.forEach((b, i) => {
      const t = (b.text ?? "").toString().trim();
      const { q, a } = splitQA(t);

      const title = (b.title ?? q ?? "").toString().trim();
      const text  = (a || t).toString().trim(); // <- RESPUESTA en text

      if (!title && !text) return;

      out.push({
        id: b.id ?? `${sourceName}-block-${i}`,
        title,               // pregunta / t√≠tulo
        text,                // respuesta (lo que mostraremos)
        tags: Array.isArray(b.tags) ? b.tags.map(String) : [],
        source: b.source ?? sourceName,
        meta: { ...(b.meta || {}), fileUrl }
      });
    });
    return out;
  }

  // Caso B: array de QAs [{question, answer, ...}, ...]
  const arr =
    Array.isArray(json) ? json :
    (json && Array.isArray(json.qas)) ? json.qas :
    (json && Array.isArray(json.qa)) ? json.qa :
    null;

  if (arr) {
    arr.forEach((qa, i) => {
      const q = (qa.question ?? qa.pregunta ?? qa.q ?? "").toString().trim();
      const a = (qa.answer ?? qa.respuesta ?? qa.a ?? "").toString().trim();
      if (!q && !a) return;

      const doc = (qa.doc ?? qa.documento ?? qa.document ?? qa.fuente ?? "").toString().trim();
      const section = (qa.source_section ?? qa.section ?? qa.seccion ?? "").toString().trim();

      out.push({
        id: qa.id ?? `${sourceName}-qa-${i}`,
        title: q,          // <- pregunta ac√°
        text: a,           // <- respuesta ac√° (CLAVE)
        tags: Array.isArray(qa.tags) ? qa.tags.map(String) : [],
        source: sourceName,
        meta: { fileUrl, doc, section }
      });
    });
    return out;
  }

  return out;
}


  
  function scoreBlock(b, qTokens, qNorm) {
    const title = normalize(b.title);
    const text  = normalize(b.text);
    const id    = normalize(b.id);
    const tags  = Array.isArray(b.tags) ? b.tags.map(normalize) : [];

    let s = 0;
    // ===== KB global (la usa answerFromKB) =====
let BLOCKS = [];

async function loadKB() {
  setKBStatus("loading", "cargando base...");

  try {
    const settled = await Promise.allSettled(
      QA_FILES.map(async (f) => {
        const json = await fetchJson(f.url);   // <- tu fetchJson
        return { file: f, json };
      })
    );

    const loaded = settled.filter(r => r.status === "fulfilled").length;

    let blocks = [];
    for (const r of settled) {
      if (r.status !== "fulfilled") continue;
      const { file, json } = r.value;
      blocks = blocks.concat(normalizeToBlocks(json, file.source, file.url));
    }

    // dedupe
    const seen = new Set();
    const uniq = [];
    for (const b of blocks) {
      const key = (b.text || "").trim();
      if (!key || seen.has(key)) continue;
      seen.add(key);
      uniq.push(b);
    }
    // Si no carg√≥ nada, no te quedes pegada en "cargando..."
if(!uniq.length){
  setKBStatus("bad", "KB vac√≠a");
  return;
}

// ESTA es la asignaci√≥n importante:
BLOCKS = uniq;

setKBStatus("ok", `KB lista ¬∑ ${BLOCKS.length} bloques`);


    // ‚úÖ CLAVE: asignar al global que usa el chat
    BLOCKS = uniq;

    // ‚úÖ CLAVE: nunca te quedes en loading
    if (!BLOCKS.length) {
      setKBStatus("bad", `KB vac√≠a ¬∑ ${loaded}/${QA_FILES.length} archivos`);
      addMsg("bot", "Cargu√© los archivos, pero no pude convertirlos a bloques. Revisa el formato de los JSON (question/answer).");
      return false;
    }

    setKBStatus("ok", `KB lista ¬∑ ${BLOCKS.length} bloques ¬∑ ${loaded}/${QA_FILES.length} archivos`);
    return true;

  } catch (err) {
    console.error(err);
    setKBStatus("bad", "KB no carg√≥");
    addMsg("bot", `No pude cargar la base (${err?.message ?? err}).`);
    return false;
  }
}

    if (qNorm && (title.includes(qNorm) || text.includes(qNorm))) s += 18;

    for (const t of qTokens) {
      if (tags.includes(t)) s += 10;
      if (title.includes(t)) s += 6;
      if (id.includes(t)) s += 4;
      if (text.includes(t)) s += 2;
    }

    if (b.source) s += 1;
    return s;
  }

 function formatEvidence(block){
  const ans = onlyAnswerFromBlock(block);
  return firstSentences(ans, 420);
}


function extractAnswerFromBlockText(raw){
  const text = String(raw || "");
  const lines = text.split(/\r?\n/);

  // Busca la l√≠nea que empieza con "A:"
  let start = -1;
  for (let i = 0; i < lines.length; i++){
    if (lines[i].trim().startsWith("A:")) { start = i; break; }
  }
  if (start === -1) return "";

  // Toma desde "A:" hasta antes de cualquier bloque meta
  const stopRe = /^(Q:|Fuente:|Documento:|Secci√≥n:|Variantes:|Tags:|Pa√≠s:|Per√≠odo:)/i;

  let out = [];
  // Primera l√≠nea: quitar "A:"
  out.push(lines[start].replace(/^A:\s*/i, "").trim());

  for (let i = start + 1; i < lines.length; i++){
    const ln = lines[i].trim();
    if (!ln) continue;
    if (stopRe.test(ln)) break;
    out.push(ln);
  }

  return out.join(" ").replace(/\s+/g, " ").trim();
}

  function answerFromKB(q){
  if(!BLOCKS.length){
    return "A√∫n no tengo la base cargada en este modo.";
  }

  const qNorm = normalize(q);
  const qTok = tokens(q);

  if(qTok.length === 0 && qNorm.length < 3){
    return "Dime un concepto, eje u objetivo (con palabras clave).";
  }

  const scored = BLOCKS
    .map(b => ({ b, s: scoreBlock(b, qTok, qNorm) }))
    .filter(x => x.s > 0)
    .sort((a,b)=> b.s - a.s);

  const detailMode = $("modeDetail").checked ? "detail" : "brief";
  const take = detailMode === "detail" ? 6 : 2;
  const top = scored.slice(0, take).map(x=>x.b);

  if(top.length === 0){
  return "Lo siento, no encontr√© evidencia suficiente. Prueba con otras palabras clave (pa√≠s, eje o concepto).";
}

  }

// ‚ö†Ô∏è A partir de ahora devolvemos SOLO respuestas (sin Q y sin Fuente),
// incluso si ‚ÄúMostrar evidencia‚Äù est√° activado.
const maxItems = (detailMode === "detail") ? 4 : 2;

const answers = top
  .map(b => extractAnswerFromBlockText(b.text))
  .filter(Boolean)
  .slice(0, maxItems);

if(!answers.length){
  return "Encontr√© material relacionado, pero no pude extraer una respuesta clara desde los bloques disponibles.";
}

// Si quieres mantener el ‚Äútono evidencia‚Äù como etiqueta (sin mostrar fuente),
// podr√≠as cambiar este return, pero por ahora lo dejamos limpio:
return answers.map(a => `‚Ä¢ ${firstSentences(a, detailMode === "detail" ? 520 : 320)}`).join("\n");
// ---- Small-talk / fuera de base (saludos, gracias, etc.) ----
const GREETINGS = [
  "hola","holi","hello","buenas","buenos dias","buenas tardes","buenas noches",
  "hey","que tal","qu√© tal","holaa"
];
const THANKS = ["gracias","muchas gracias","vale","bacan","bkn","genial","perfecto","ok gracias"];
const BYE = ["chao","chau","adios","adi√≥s","hasta luego","nos vemos","bye"];
const WHO = ["quien eres","qui√©n eres","que eres","qu√© eres","que haces","qu√© haces","como funcionas","c√≥mo funcionas","ayuda","help"];

function matchAnyPhrase(qNorm, phrases){
  return phrases.some(p => {
    const pn = normalize(p);
    return qNorm === pn || qNorm.startsWith(pn + " ") || qNorm.includes(" " + pn + " ");
  });
}

function detectIntent(q){
  const qNorm = normalize(q);

  if (!qNorm) return "empty";
  if (matchAnyPhrase(qNorm, GREETINGS)) return "greet";
  if (matchAnyPhrase(qNorm, THANKS)) return "thanks";
  if (matchAnyPhrase(qNorm, BYE)) return "bye";
  if (matchAnyPhrase(qNorm, WHO)) return "who";
  if (qNorm.length <= 3) return "too_short";

  return null; // sigue al KB normal
}

function replyForIntent(intent){
  switch(intent){
    case "empty":
    case "too_short":
      return `¬øQu√© quieres revisar? Puedo responder usando los textos.
Ejemplos:
‚Ä¢ ‚Äúmicrocredenciales‚Äù
‚Ä¢ ‚Äúgobernanza‚Äù
‚Ä¢ ‚Äúobjetivo 6‚Äù
‚Ä¢ ‚Äú¬øQu√© propone la Estrategia de Educaci√≥n Superior sobre docencia?‚Äù`;

    case "greet":
      return `¬°Hola! üê• Dime un concepto, eje u objetivo y te respondo desde los textos.
Ejemplos: ‚Äúmicrocredenciales‚Äù, ‚ÄúI+D‚Äù, ‚Äúgobernanza‚Äù, ‚Äúobjetivo 2‚Äù.`;

    case "thanks":
      return `¬°De nada! üê• Si quieres, dime un concepto, eje u objetivo y lo buscamos en los textos.`;

    case "bye":
      return `¬°Listo! üê• Si vuelves, dime un concepto, eje u objetivo y seguimos.`;

    case "who":
      return `Soy Albito üê•. Respondo usando los textos cargados (sin inventar).
P√≠deme un concepto, eje u objetivo y te contesto con una s√≠ntesis.`;

    default:
      return `Puedo ayudarte s√≥lo con lo que est√° en los textos. Dime un concepto, eje u objetivo.`;
  }
}

  function send() {
    const qEl = $("q");
    const q = (qEl ? qEl.value : "").trim();
    if (!q) return;

    addMsg("me", q);
    if (qEl) qEl.value = "";

    const toneEl = $("tone");
    const tone = toneEl ? toneEl.checked : true;
    const prefix = tone ? "¬°Listo!üê•. " : "";

    try {
      const intent = detectIntent(q);
if(intent){
  addMsg("bot", prefix + replyForIntent(intent));
  return;
}

const resp = answerFromKB(q);
addMsg("bot", prefix + resp);
    } catch (err) {
      console.error(err);
      addMsg("bot", "Ups‚Ä¶ hubo un error interno al responder. (Revisa la consola F12 ‚Üí Console)");
    }
  }

  $("btnSend").addEventListener("click", send);
  $("q").addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); send(); }
  });

  $("btnClear").addEventListener("click", () => {
    chatEl.innerHTML = "";
    greeting();
  });

  $("btnCopy").addEventListener("click", async () => {
    const bodies = [...document.querySelectorAll(".row.bot .bubble .body")];
    if (!bodies.length) return;
    const last = bodies[bodies.length - 1].textContent || "";
    try { await navigator.clipboard.writeText(last.trim()); } catch {}
  });

  // Init
  greeting();
  loadKB();
</script>

</body>
</html>      